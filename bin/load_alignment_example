#!/usr/bin/env python

import argparse
import json
import logging

import matplotlib.pyplot as plt
import numpy as np

import partitura
from partitura.utils import partition
import basismixer.basisfunctions
from basismixer.utils import pair_files
import basismixer.performance_codec as pc


def main():
    parser = argparse.ArgumentParser(description="Extract match information for performance codec")
    parser.add_argument("xmlfolder", help="Folder with MusicXML files")
    parser.add_argument("matchfolder", help="Folder with match files")
    args = parser.parse_args()

    folders = dict(xml=args.xmlfolder, match=args.matchfolder)

    for piece, files in pair_files(folders).items():
        # if not piece.startswith('Mozart_K331_1st-mov'):
        if not piece.startswith('Mozart_K331_1st'):
            continue
        part = partitura.load_musicxml(files['xml'].pop(), validate=False)
        # for n in part.iter_all(partitura.score.GenericNote, include_subclasses=True):
        #     n.symbolic_duration = None
        # part.multiply_quarter_durations(10)
        partitura.score.expand_grace_notes(part, max_prop=.2)
        # partitura.save_score_midi(part, '/tmp/out.mid')

        with open('/tmp/pretty.txt', 'w') as pretty:
            pretty.write(part.pretty())

        for match in files['match']:
            # if not 'p12' in match:
            #     continue
            print(match)
            # if not 'p01' in match:
            #     continue
            ppart, alignment = partitura.load_match(match, first_note_at_zero=True)

            dyn_codec = pc.OnsetwiseDecompositionDynamicsCodec()
            time_codec = pc.TimeCodec(normalization='standardized_bp')
            perf_codec = pc.PerformanceCodec(time_codec, dyn_codec)
            targets, snote_ids = perf_codec.encode(part, ppart, alignment)

            rec_perf = perf_codec.decode(part, targets, snote_ids=snote_ids)

            # compare reconstructed performance to original performance
            id_map = dict((a['performance_id'], a['score_id']) for a in alignment
                          if a['label'] == 'match')
            note_ids = sorted(id_map.keys())
            orig_notes = [ppart.notes[i] for i in note_ids]
            rec_note_dict = dict((n['id'], n) for n in rec_perf.notes)
            rec_notes = [rec_note_dict[id_map[i]] for i in note_ids]

            assert all(n['velocity']==rn['velocity'] for n, rn in zip(orig_notes, rec_notes))
            onsets = np.array([(n['note_on'], rn['note_on']) for n, rn in zip(orig_notes, rec_notes)])
            assert np.all(np.isclose(onsets[:, 0], onsets[:, 1]))
            offsets = np.array([(n['sound_off'], rn['sound_off']) for n, rn in zip(orig_notes, rec_notes)])
            assert np.all(np.isclose(offsets[:, 0], offsets[:, 1]))
            # rtol=1e-5, atol=1e-5))

            # plot targets
            bm = part.beat_map
            snote_dict = dict((n.id, n) for n in part.notes_tied)
            # onsets = bm([n.start.t for n, _ in note_pairs])
            onsets = bm([snote_dict[i].start.t for i in snote_ids])
            measure_times = np.array([(m.start.t, m.number) for m in part.iter_all(partitura.score.Measure)])
            measure_times[:, 0] = bm(measure_times[:, 0])
            np.savetxt('/tmp/out.txt', onsets)
            plot_targets(targets, perf_codec.parameter_names, '/tmp/out.pdf', onsets=onsets, xticks=measure_times, title=match)


def plot_targets(targets, names, out_fn, onsets=None, xticks=None, title=None):

    n_targets = len(targets.dtype.names)

    if onsets is None:
        x = np.arange(len(targets))
    else:
        x = onsets

    w = len(x) / 30
    h = n_targets

    fig, axs = plt.subplots(n_targets, sharex=True,
                            gridspec_kw={'hspace': 0.15})
    if n_targets == 1:
        axs = [axs]

    fig.set_size_inches(w, h)

    if title:
        fig.suptitle(title)

    for i, name in enumerate(names):
        axs[i].plot(x, targets[name], '.', label=name)

        if xticks is not None:
            axs[i].set_xticks(xticks[:, 0])
            axs[i].set_xticklabels(xticks[:, 1])
            axs[i].xaxis.grid()

        by_onset = partition(lambda ix: ix[1], enumerate(x))
        tt = []
        vv = []
        for t, v in by_onset.items():
            tt.append(t)
            vv.append(np.mean([targets[name][j] for j, _ in v]))

        # ymax = np.mean(vv) + 2 * np.std(vv)
        # ymin = np.mean(vv) - 2 * np.std(vv)
        ymax = np.mean(vv) + 3 * np.std(targets[name])
        ymin = np.mean(vv) - 3 * np.std(targets[name])

        axs[i].set_ylim((np.minimum(ymin, np.mean(vv) - .1),
                         np.maximum(ymax, np.mean(vv) + .1)))

        # ymin = np.min(np.r_[vv, targets[name]])
        # ymax = np.max(np.r_[vv, targets[name]])

        # axs[i].set_ylim((ymin, ymax))

        axs[i].plot(tt, vv)

        axs[i].legend(frameon=False, loc=1)

    fig.savefig(out_fn, bbox_inches='tight')
    plt.close(fig)


if __name__ == '__main__':
    main()
